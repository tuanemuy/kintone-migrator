# 利用シナリオ詳細

## 前提

- UIはレコード一覧画面のヘッダースペースに表示する
- ヘッダースペースは横幅が限られるため、操作のエントリーポイントはコンパクトにまとめる
- メイン操作はドロップダウンメニューでまとめ、「フォーム管理」ボタンから展開する
- 各操作の詳細表示や確認にはダイアログ（モーダル）を使用する
    - ダイアログを選択する理由: レコード一覧画面のコンテキストを維持しつつ、操作に集中させるため
    - ページ遷移は行わない（kintoneカスタマイズの制約上、同一画面内で完結させる）

## 画面構成

```
[レコード一覧画面のヘッダースペース]
┌─────────────────────────────────────┐
│  [フォーム管理 ▼]                     │
│    ├ 差分を確認する                    │
│    ├ マイグレーションを実行する          │
│    ├ 強制的に上書きする                 │
│    └ 現在の設定を取り込む               │
└─────────────────────────────────────┘
```

---

## シナリオ1: 管理者用メモの宣言的設定と現在のフォーム設定の差分を確認する

### 目的

フォーム設定を変更する前に、管理者用メモに記載した宣言的設定と実際のフォーム設定の間にどのような差分があるかを把握する。

### フロー

1. 利用者はレコード一覧画面を開く
2. ヘッダースペースの「フォーム管理」ドロップダウンメニューから「差分を確認する」を選択する
3. システムは以下を並行して取得する
    - 管理者用メモに記載された宣言的設定をパースする
    - kintone REST APIで現在のフォームフィールド設定を取得する
4. システムは両者を比較し、差分を検出する
5. **ダイアログ**が開き、差分の一覧を表示する

### ダイアログの表示内容

- タイトル: 「フォーム設定の差分」
- 差分がある場合:
    - 変更種別ごとにセクションを分けて表示する
        - **追加**: 宣言的設定にあるが、現在のフォームにないフィールド
        - **変更**: 両方に存在するが設定値が異なるフィールド
        - **削除**: 現在のフォームにあるが、宣言的設定にないフィールド
    - 各フィールドについて以下を表示する
        - フィールドコード
        - フィールド名
        - 変更内容の要約（例: 「必須 → 任意」「新規追加」など）
    - 変更件数のサマリーを上部に表示する（例: 追加 2件, 変更 3件, 削除 1件）
- 差分がない場合:
    - 「差分はありません。フォーム設定は宣言的設定と一致しています。」と表示する
- フッター: 「閉じる」ボタン

### エラー時

- 管理者用メモのパースに失敗した場合: ダイアログ内にエラーメッセージを表示する（例: 「管理者用メモの設定を読み取れませんでした。記述形式を確認してください。」）
- API取得に失敗した場合: ダイアログ内にエラーメッセージを表示する（例: 「フォーム設定の取得に失敗しました。」）

---

## シナリオ2: マイグレーションを実行してフォーム設定を更新する

### 目的

管理者用メモの宣言的設定と現在のフォーム設定の差分を確認した上で、差分のみを適用してフォーム設定を更新する。

### フロー

1. 利用者はレコード一覧画面を開く
2. ヘッダースペースの「フォーム管理」ドロップダウンメニューから「マイグレーションを実行する」を選択する
3. システムは差分を検出する（シナリオ1と同様の処理）
4. **確認ダイアログ**が開き、適用される変更の一覧を表示する

### 確認ダイアログの表示内容

- タイトル: 「マイグレーションの確認」
- 差分がある場合:
    - シナリオ1と同様の差分一覧を表示する
    - 注意書き: 「以下の変更をフォーム設定に適用します。」
    - フッター:
        - 「キャンセル」ボタン（ダイアログを閉じる）
        - 「実行する」ボタン（プライマリ、マイグレーションを実行する）
- 差分がない場合:
    - 「差分はありません。マイグレーションは不要です。」と表示する
    - フッター: 「閉じる」ボタン

### 実行中の表示

- 「実行する」ボタンを押すと、ボタンがローディング状態になる
- ダイアログは開いたまま、操作を受け付けない状態にする

### 実行完了後

- 成功時: ダイアログを閉じ、トースト通知で「マイグレーションが完了しました。」と表示する
- 失敗時: ダイアログ内にエラーメッセージを表示する（例: 「マイグレーションに失敗しました: フィールド○○の追加でエラーが発生しました。」）。ダイアログは閉じずに、利用者がエラー内容を確認できるようにする

---

## シナリオ3: 管理者用メモの設定でフォーム設定を強制的に上書きする

### 目的

差分の有無にかかわらず、管理者用メモの宣言的設定でフォーム設定を完全に上書きする。宣言的設定に含まれないフィールドは削除される。

### フロー

1. 利用者はレコード一覧画面を開く
2. ヘッダースペースの「フォーム管理」ドロップダウンメニューから「強制的に上書きする」を選択する
3. システムは現在のフォーム設定と宣言的設定の両方を取得する
4. **警告ダイアログ（AlertDialog）** が開き、上書き内容を表示する

### 警告ダイアログの表示内容

- タイトル: 「フォーム設定の強制上書き」
- 警告アイコンと警告メッセージ: 「この操作はフォーム設定を宣言的設定で完全に上書きします。宣言的設定に含まれないフィールドは削除されます。この操作は元に戻せません。」
- 上書き後のフィールド一覧を表示する
- 削除されるフィールドがある場合は強調表示する（destructiveスタイル）
- フッター:
    - 「キャンセル」ボタン（ダイアログを閉じる）
    - 「上書きする」ボタン（destructiveスタイル、上書きを実行する）

### 実行中の表示

- シナリオ2と同様にローディング状態にする

### 実行完了後

- 成功時: ダイアログを閉じ、トースト通知で「フォーム設定を上書きしました。」と表示する
- 失敗時: ダイアログ内にエラーメッセージを表示する。ダイアログは閉じない

---

## シナリオ3a: フォーム設定をリセットして全カスタムフィールドを削除する

### 目的

フォームからすべてのカスタムフィールドを削除し、空の初期状態に戻す。テスト環境のクリーンアップや、フォーム設定をゼロから作り直す際に使用する。CLIでは `override --reset` フラグで実行する。

### 前提

- `--reset` と `--schema` フラグは排他的であり、同時に指定した場合は `ValidationError` となる
- スキーマファイルの指定は不要

### フロー（CLI）

1. 利用者は `override --reset` を実行する
2. システムは `FormConfigurator.getFields()` で現在のフォーム設定を取得する
3. システムはシステムフィールドを除外し、削除対象のカスタムフィールドを特定する
4. 削除対象フィールドの一覧を表示し、確認プロンプトを表示する
    - 「全 N 件のカスタムフィールドを削除してフォームをリセットします。この操作は元に戻せません。続行しますか？ (y/N)」
5. 利用者が確認した場合、`FormConfigurator.deleteFields()` で全カスタムフィールドを削除する
6. `FormConfigurator.updateLayout()` で空のレイアウトに更新する

### 出力例

```
Reset target: 12 custom fields will be deleted.

Fields to delete:
  - customer_name (SINGLE_LINE_TEXT)
  - customer_code (SINGLE_LINE_TEXT)
  - email (SINGLE_LINE_TEXT)
  ...

⚠ All 12 custom fields will be deleted and the form will be reset. This cannot be undone.
Continue? (y/N): y

Deleting fields... done.
Updating layout... done.

Form has been reset successfully.
```

### カスタムフィールドがない場合

```
No custom fields found. The form is already in its initial state.
```

### Multi-Appモード

- `override --reset --all` で全アプリのフォームを一括リセットできる
- 依存関係の逆順（依存されているアプリを後に）でリセットを実行する
    - 理由: 参照先アプリのフィールドを先に削除すると、参照元のLookupフィールド等が不整合になる可能性があるため
- 1回の確認プロンプトで全アプリの実行を開始する
- Fail-Fast方式: 1つのアプリで失敗した場合、残りのアプリはスキップされる

### エラー時

- `--reset` と `--schema` を同時に指定した場合: `ValidationError`（「--reset と --schema は同時に指定できません。」）
- `FormConfigurator.getFields()` の通信に失敗した場合: `SystemError` を表示する
- `FormConfigurator.deleteFields()` の通信に失敗した場合: `SystemError` を表示し、処理を中断する

---

## シナリオ4: 稼働中のフォーム設定から宣言的な構成を生成して管理者用メモに反映する

### 目的

既にフォーム設定が存在するアプリに対して、現在の設定を宣言的な構成として管理者用メモに書き出す。初回導入時や、手動で変更した設定を宣言的管理に取り込む際に使用する。

### フロー

1. 利用者はレコード一覧画面を開く
2. ヘッダースペースの「フォーム管理」ドロップダウンメニューから「現在の設定を取り込む」を選択する
3. システムはkintone REST APIで現在のフォームフィールド設定を取得する
4. システムは取得した設定を宣言的な構成フォーマットに変換する
5. **確認ダイアログ**が開き、生成された構成のプレビューを表示する

### 確認ダイアログの表示内容

- タイトル: 「設定の取り込み」
- 生成された宣言的設定のプレビューを表示する（スクロール可能な領域に表示）
- 管理者用メモに既に設定が存在する場合は注意書きを表示する: 「管理者用メモの既存の設定は上書きされます。」
- フッター:
    - 「キャンセル」ボタン（ダイアログを閉じる）
    - 「反映する」ボタン（プライマリ、管理者用メモに書き出す）

### 実行中の表示

- シナリオ2と同様にローディング状態にする

### 実行完了後

- 成功時: ダイアログを閉じ、トースト通知で「管理者用メモに設定を反映しました。」と表示する
- 失敗時: ダイアログ内にエラーメッセージを表示する。ダイアログは閉じない

---

## シナリオ5: 複数アプリを依存順に一括操作する（Multi-Appモード）

### 目的

プロジェクト設定ファイル（`kintone-migrator.yaml`）で定義された複数のkintoneアプリに対して、依存関係に基づいた順序で一括操作（diff/migrate/override/capture/dump）を実行する。

### 前提

- `kintone-migrator.yaml` がプロジェクトルートに配置されている
- CLI引数 `--all` で全アプリ一括実行、`--app <name>` で単一アプリ実行

### フロー（`--all` での一括 migrate の例）

1. 設定ファイルを読み込み、バリデーションを実行する
2. 依存関係を解決し、トポロジカルソートで実行順序を決定する
3. 各アプリのdiffを依存順に検出して表示する
4. 変更サマリーを表示し、1回の確認プロンプトで続行を問う
5. 利用者が確認した場合、依存順に各アプリのmigration + deployを実行する
6. 失敗時は即停止し、残りのアプリはスキップする

### 出力例

```
=== [customer] (app: 10) ===
Migration + Deploy completed.

=== [order] (app: 20) ===
[SystemError] EXTERNAL_API_ERROR: Failed to add form fields

Execution stopped.
  ✓ Succeeded: customer
  ✗ Failed: order
  - Skipped: invoice
```

### エラー時

- 設定ファイルが見つからない場合: ValidationErrorを表示
- 循環依存が検出された場合: BusinessRuleErrorを表示
- 実行中のアプリが失敗した場合: Fail-Fastで即停止、結果サマリーを表示
